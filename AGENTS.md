## Цель и область применения

Этот документ фиксирует единые правила разработки и тестирования в проекте. Здесь собраны требования к структуре кода,
стилю комментариев, оформлению и написанию unit-тестов, использованию Moq и FluentAssertions, а также чек-лист приёмки.

---

## Язык и комментарии (XML-док)

1. **Русский язык везде.** Все комментарии и тексты `summary`, `DisplayName`, имена тестов и пояснения пишутся
   по-русски.
2. **`<summary>` на всём, что не `private`.** Любой публичный и `internal` тип/член обязан иметь `summary` с понятным
   пояснением назначения в одном предложении.
3. **Единый формат XML-доков:**

    * В `summary` текст начинается с табуляции `\t`.&#x20;
    * На уровне класса всегда добавляем `<remarks>` с нумерованным списком `<list type="number">` без `<description>`
      внутри. На методах `remarks` не ставим.&#x20;
4. **Конструкторы тест-классов** помечаем `<inheritdoc/>`.&#x20;

---

## Структура проекта и файлов

1. Каждая сущность в отдельном файле: все классы, рекорды, интерфейсы, перечисления выносятся в собственные файлы.
2. `using`-директивы упорядочены и не «плавают».&#x20;

---

## Базовые правила C\#

1. **`var` вместо явного типа**, если это не снижает читаемость.
2. **Фигурные скобки ставим всегда**, даже для однострочных веток и циклов.

---

## Правила unit-тестов

### Общие требования

1. **Перед реализацией** формируется **полный список тест-кейсов** по покрываемому классу: корректные сценарии, ошибки,
   edge-кейсы, пустые входы, несоответствия контракту и т.п.
2. **Язык и стиль имен:** русские `summary` и `DisplayName`, названия тестов в едином формате:
   `Тест N: Краткое, но точное описание проверяемого поведения`. `DisplayName` должен быть **в точности равен** тексту
   `summary`.&#x20;
3. **Атрибуты:** используем `[Fact]` и при необходимости `[Theory]`. Для обоих задаём `DisplayName`. Не применяем
   `InlineData`, если это не абсолютно необходимо.&#x20;
4. **Асинхронность:** только `await`. Запрещено обращаться к `.Result` или блокировать поток синхронными
   ожиданиями.&#x20;
5. **Ассерты:** FluentAssertions. Предпочтительный стиль: `x.Should().Be(...)`, проверка списков и коллекций через
   соответствующие расширения. Запрещены лямбды внутри `Assert`.&#x20;
6. **Возвраты коллекций в моках:** используем лаконичную форму `ReturnsAsync([])`, не `Array.Empty<T>()`.&#x20;
7. **Работа с результатами операций:** читаем данные из `OperationResult.Data`, не используем `.Value`. Ошибки проверяем
   через `Should().Contain(...)`.&#x20;
8. **Инициализация моделей в Arrange:** явная, читаемая форма, например `Ticker = new() { Symbol = "AAPL" }`.&#x20;

### Moq: сетапы и верификации

1. **Verify:** используем `Times.Once` и, когда уместно, `It.IsAny<Expression<...>>()`. Верификации обязательны для
   критичных взаимодействий.&#x20;
2. **Свойства:** для чтения свойств применяем только `.SetupGet(x => x.Property)`. Не «хачим» через `.Callback`.&#x20;

---

## Запреты и анти-паттерны

* `[Theory]` с `InlineData` без веской причины.&#x20;
* `.Result`, `.GetAwaiter().GetResult()`, любые синхронные ожидания Task.&#x20;
* Лямбды в `Assert`.&#x20;
* `Array.Empty<T>()` там, где читаемее `[]`.&#x20;
* Слова вроде «допустим», «возможно», «вариант» в тест-описаниях и комментариях. Формулировки категоричные и
  проверяемые.
* Отсутствие фигурных скобок.
* Английские комментарии и смешение языков.

---

## Формат тест-классов

```csharp
/// <summary>
/// 	Тест 1: Должен вернуть корректный результат при валидных входных данных
/// </summary>
[Fact(DisplayName = "Тест 1: Должен вернуть корректный результат при валидных входных данных")]
public async Task Should_ReturnExpectedResult_WhenInputIsValid()
{
	// Arrange
	var sut = CreateSut();
	var input = new() { /* ... */ };

	// Act
	var result = await sut.DoAsync(input, CancellationToken.None);

	// Assert
	result.IsSuccess.Should().BeTrue();
	result.Data.Should().Be(/* ожидаемое */);
}
```

```csharp
/// <summary>
/// 	Тест 2: Должен корректно обрабатывать пустую коллекцию входных данных
/// </summary>
[Fact(DisplayName = "Тест 2: Должен корректно обрабатывать пустую коллекцию входных данных")]
public async Task Should_HandleEmptyInput()
{
	// Arrange
	var sut = CreateSut();
	var repo = new Mock<IRepository>();
	repo.Setup(x => x.LoadAsync(It.IsAny<CancellationToken>())).ReturnsAsync([]); // ok
	// ...

	// Act
	var items = await sut.LoadAsync(CancellationToken.None);

	// Assert
	items.Should().BeEmpty();
	repo.Verify(x => x.LoadAsync(It.IsAny<CancellationToken>()), Times.Once); // ok
}
```

```csharp
/// <summary>
/// 	Тест 3: Должен читать свойство конфигурации через SetupGet
/// </summary>
[Fact(DisplayName = "Тест 3: Должен читать свойство конфигурации через SetupGet")]
public void Should_SetupGet_ForProperties()
{
	// Arrange
	var cfg = new Mock<IConfig>();
	cfg.SetupGet(x => x.Timeout).Returns(TimeSpan.FromSeconds(1)); // только SetupGet

	// Act
	var timeout = cfg.Object.Timeout;

	// Assert
	timeout.Should().Be(TimeSpan.FromSeconds(1));
}
```

```csharp
/// <summary>
/// 	Тест 4: Должен писать ошибки в OperationResult и содержать ожидаемое сообщение
/// </summary>
[Fact(DisplayName = "Тест 4: Должен писать ошибки в OperationResult и содержать ожидаемое сообщение")]
public async Task Should_ReturnError_WithExpectedMessage()
{
	// Arrange
	var sut = CreateSut();
	// ...

	// Act
	var result = await sut.DoAsync(null!, CancellationToken.None);

	// Assert
	result.IsSuccess.Should().BeFalse();
	result.Error.Should().Contain("некорректные данные"); // проверяем текст ошибки
}
```

> Примечания к формату:
>
> * В конструкторе тест-класса ставим `<inheritdoc/>`.&#x20;
> * `DisplayName` всегда совпадает с `summary`.&#x20;
> * Для свойств — только `.SetupGet(...)`.&#x20;
> * Для взаимодействий — `Verify(..., Times.Once)`.&#x20;
> * Коллекции из моков — `ReturnsAsync([])`.&#x20;

---

## Чек-лист PR (Definition of Done)

**Код**

* [ ] Все публичные и `internal` члены имеют `summary` на русском.
* [ ] На уровне класса есть `remarks` с `<list type="number">` без `<description>`. На методах `remarks`
  отсутствуют.&#x20;
* [ ] Каждая сущность в отдельном файле; `using`-директивы упорядочены.&#x20;
* [ ] В местах, где понятно типизируется, используется `var`.
* [ ] Ветвления и циклы со скобками, даже если одна строка.

**Тесты**

* [ ] Перед реализацией приложен полный перечень тест-кейсов.
* [ ] У каждого теста есть `summary`; `DisplayName` идентичен `summary` и в формате `Тест N: ...`.&#x20;
* [ ] Нет `InlineData` без необходимости; нет `.Result`; нет лямбд в `Assert`.&#x20;
* [ ] Используются FluentAssertions (`Should().Be(...)` и т.п.).
* [ ] Коллекции в моках возвращаются через `ReturnsAsync([])`.&#x20;
* [ ] Для свойств — `.SetupGet(...)`; критичные вызовы проверены `Verify(..., Times.Once)`.&#x20;
* [ ] В тест-классе конструктор с `<inheritdoc/>`.&#x20;
* [ ] Для `OperationResult` читается `Data`, а ошибки проверяются содержательно через `Should().Contain(...)`.&#x20;
* [ ] Нет слов «допустим», «возможно», «вариант» в комментариях и описаниях.

---

## Мини-памятка по именованию тестов

* `Тест N: <краткая формулировка поведения>` — в `summary` и в `DisplayName`.&#x20;
* Имя метода на английском в стиле `Should_<ExpectedBehavior>_When_<Condition>()`.

---

## Пример шаблона класса тестов

```csharp
/// <summary>
/// 	Тесты для SomeService: проверка корректности обработки входных данных, ошибок и граничных случаев
/// </summary>
/// <remarks>
/// 	<list type="number">
/// 		<item>Проверяется happy-path</item>
/// 		<item>Проверяются ошибки валидации</item>
/// 		<item>Проверяются edge-кейсы (пустые входы, null и т.д.)</item>
/// 	</list>
/// </remarks>
public sealed class SomeServiceTests
{
	/// <inheritdoc/>
	public SomeServiceTests()
	{
		// общая инициализация окружения тестов
	}

	/// <summary>
	/// 	Тест 1: Должен вернуть корректный результат при валидном запросе
	/// </summary>
	[Fact(DisplayName = "Тест 1: Должен вернуть корректный результат при валидном запросе")]
	public async Task Should_ReturnData_OnValidRequest()
	{
		// Arrange
		// ...

		// Act
		// ...

		// Assert
		// ...
	}
}
```

---

## Заключение

Следуем этим правилам без отклонений. Любые новые соглашения попадают в этот документ и становятся обязательными после
согласования в ревью.
